#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "includes/algorithms.h"
#include "includes/utils.h"

void (*algorithm)(int*, int, int) = NULL;
FILE* file = NULL;
int* random_arr = NULL;
char* file_name = NULL;
clock_t* shell_times = NULL;
clock_t* insert_times = NULL;
int file_size = 0;
short multiplier = 1;
int ra_size = 0;
short benchmark_mode = 0;

int main(int argc, char** argv) {

	alg_fs[0] = shell_sort;
	alg_fs[1] = insertion_sort;

	MAX_RAND = RAND_MAX;

	srand(time(0));

	for (int i = 1; i < argc; i++) {

		//printf("i = %d: %s\n", i, argv[i]);

		if (!strcmp(argv[i], "-a") || !strcmp(argv[i], "--algorithm")) { // check is next arg possible algorithm and make variable for it

			if ((i + 1) < argc && (algorithm = return_algo(argv[i + 1])))
				i++;

			else {

				printf("Parameter after %s should be a valid algorithm. For exmaples check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-b") || !strcmp(argv[i], "--benchmark")) // set benchmark mode
			benchmark_mode = 1;

		else if (!strcmp(argv[i], "--dataset")) { // set dataset for benchmark

			dataset_size = 0;

			dataset = (int*)malloc(sizeof(int));

			while ((i + dataset_size + 1) < argc && return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]))) {

				dataset[dataset_size] = return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]));
				dataset = (int*)realloc(dataset, ++dataset_size);
			}

			if (dataset_size == 0) {

				printf("You must specify at least 1 not null number after %s parameter.\n", argv[i]);
				return 0;
			}

			else
				i += dataset_size;

		}

		else if (!strcmp(argv[i], "-f") || !strcmp(argv[i], "--file")) { // check is next arg an existing file

			if ((i + 1) < argc)
				file_name = argv[++i];

			else {

				printf("Parameter after %s should be a valid filename. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) { // help option

			printf("Manual for sorting program.\n");
			printf("Usage options:\n");
			printf("\t-a, --algorithm [ shell_sort, shellsort, shell, insertion_sort, insertionsort, insertion ] \t set sorting algorithm\n");
			printf("\t-b, --benchmark \t set benchmark mode. Should be used with --dataset parameter\n");
			printf("\t--dataset [ N1, N2, ... ] \t setting count of integers will be generated to make a benchmark. Will be generated N1 integers for first test, N2 integers for second test etc\n");
			printf("\t-f, --file [ filename ] \t setting name of file with numbers that will be sorted. Program puts sorted integers in this file\n");
			printf("\t-m, --max-num [ N ] \t setting max number that can be generated by a program\n");
			printf("\t-n, --no-sort [ N ] \t generate file with random integers without sorting. After paramater should given number with count of integers in file\n");
			printf("\t-r, --reverse \t setting reverse sorting mode\n");
			printf("\t-h, --help \t display this manual\n");

			return 0;
		}

		else if (!strcmp(argv[i], "-m") || !strcmp(argv[i], "--max-num")) { // set maximum random generated number, default is RAND_MAX constant

			if ((i + 1) < argc && return_num(argv[i + 1], strlen(argv[i + 1]))) {
			
				MAX_RAND = return_num(argv[i + 1], strlen(argv[i + 1]));
				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-n") || !strcmp(argv[i], "--no-sort")) {	// generate file with random numbers without sorting

			if ((i + 1) < argc && (ra_size = return_num(argv[i + 1], strlen(argv[i + 1])))) {
				
				random_arr = get_random_array(ra_size);
				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-r") || !strcmp(argv[i], "--reverse")) // set reverse flag
			multiplier = -1;

		else { // unknown option, exiting

			printf("Unknown option, use --help for more information.\n");
			return 0;
		}
	}


	if (ra_size) {

		file_name = file_name ? file_name : "output.txt";
		file = fopen(file_name, "w+");

		if (!file)
			printf("Unable to open/create file.\n");
		
		else
			get_random_file(file, ra_size);

		return 0;
	}

	if (benchmark_mode) {

		if (dataset_size >= 1 && check_dataset()) {

			shell_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);
			insert_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);

			int* arr_shell;
			int* arr_insert;

			for (int i = 0; i < dataset_size; i++) {

				arr_shell = get_random_array(dataset[i]);
				arr_insert = get_random_array(dataset[i]);

				shell_times[i] = benchmark(arr_shell, dataset[i], alg_fs[SHELL_SORT], multiplier);
				insert_times[i] = benchmark(arr_insert, dataset[i], alg_fs[INSERTION_SORT], multiplier);

			}


			printf("\n\n========RESULTS FOR SHELL SORT=========\n\n");

			for (int k = 0; k < dataset_size; k++) {

				printf("Array size: %d, clocks: %ld, seconds: %ld\n", dataset[k], shell_times[k], shell_times[k] / CLOCKS_PER_SEC);

			}

			printf("\n=======================================\n");

			printf("\n\n========RESULTS FOR INSERTION SORT=========\n\n");

			for (int k = 0; k < dataset_size; k++) {

				printf("Array size: %d, clocks: %ld, seconds: %ld\n", dataset[k], insert_times[k], insert_times[k] / CLOCKS_PER_SEC);

			}

			printf("\n===========================================\n");
		}

		else
			printf("You must specify --dataset parameter without null numbers.\n");
		
		return 0;
	}

	if (file_name) {

		if (!algorithm)
			algorithm = alg_fs[rand() % 2];

		file = fopen(file_name, "r+");

		if (!file)
			printf("File doesn\'t exist or can\'t be opened.\n");

		else {

			int file_size = 0;
			int* arr = read_file(file, &file_size);

			algorithm(arr, file_size, multiplier);

			freopen(file_name, "w", file);

			write_file(file, arr, file_size);
		}

		return 0;
	}

	return 0;
}